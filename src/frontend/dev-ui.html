<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Dev Services Dashboard</title>
    <link rel="icon" href="/favicon.ico" type="image/x-icon" />
    <link rel="stylesheet" href="/styles.css" />
  </head>
  <body>
    <header>
      <h1>Dev Services Dashboard</h1>
    </header>

    <div class="tab-container">
      <div class="tab-nav" id="tab-nav">
        <div class="tabs-left" id="tabs-left" role="tablist">
          <!-- Tabs will be dynamically generated here -->
        </div>
        <div class="global-controls">
          <button id="start-all-btn" title="Start all services">
            Start All
          </button>
          <span id="start-all-status" class="start-all-status"></span>
        </div>
      </div>
    </div>

    <div class="main-content">
      <div class="tab-content-container" id="tab-content-container">
        <!-- Tab content will be dynamically generated here -->
      </div>
    </div>

    <script>
      let socket = null;
      const MAX_CLIENT_LOGS = 500; // Max logs to keep in browser per service
      let activeServicesConfig = []; // Will be populated by fetch
      let activeTabId = null;
      let startAllInProgress = false;
      let autoScrollStates = {}; // Track auto-scroll state for each service

      // Maps to store timeouts
      const errorMessageTimeouts = new Map(); // For error messages
      const statusMessageTimeouts = new Map(); // For status messages

      function createServiceTab(service) {
        // Create tab button
        const tabsLeft = document.getElementById("tabs-left");
        const tabButton = document.createElement("button");
        tabButton.className = "tab-button";
        tabButton.id = `tab-${service.id}`;
        tabButton.setAttribute("role", "tab");
        tabButton.setAttribute("aria-controls", `content-${service.id}`);
        tabButton.setAttribute("aria-selected", "false");
        tabButton.setAttribute("title", `View ${service.name} service`);

        // Create the status indicator and text in separate spans for better alignment
        const statusIndicator = document.createElement("span");
        statusIndicator.className = "tab-status-indicator status-stopped";
        statusIndicator.id = `${service.id}-tab-status-indicator`;

        const tabText = document.createElement("span");
        tabText.textContent = service.name;

        tabButton.appendChild(statusIndicator);
        tabButton.appendChild(tabText);

        tabButton.addEventListener("click", () => switchTab(service.id));
        tabsLeft.appendChild(tabButton);

        // Create tab content
        const tabContentContainer = document.getElementById(
          "tab-content-container",
        );
        const tabContent = document.createElement("div");
        tabContent.className = "tab-content";
        tabContent.id = `content-${service.id}`;
        tabContent.setAttribute("role", "tabpanel");
        tabContent.setAttribute("aria-labelledby", `tab-${service.id}`);
        tabContent.setAttribute("tabindex", "0");

        tabContent.innerHTML = `
          <div class="service-header">
            <h2 class="service-title">${service.name}</h2>
            <div class="service-status">
              <span class="status-indicator status-stopped" id="${service.id}-status-indicator"></span>
              <span id="${service.id}-status-text">stopped</span>
            </div>
          </div>

          <div class="service-content">
            <div id="${service.id}-error-details" class="error-details" style="display:none;"></div>

            <div class="controls">
              <button id="${service.id}-start" title="Start ${service.name}">Start</button>
              <button id="${service.id}-stop" class="stop-button" title="Stop ${service.name}">Stop</button>
              <button id="${service.id}-restart" class="restart-button" title="Restart ${service.name}">Restart</button>
              <button id="${service.id}-clear-logs" class="clear-logs-button" title="Clear logs for ${service.name}">Clear Logs</button>
              ${createWebLinkButtons(service)}
            </div>

            <div class="logs-container">
              <div class="log-controls">
                <h3>Logs</h3>
              </div>

              <div class="log-status-bar">
                <div id="${service.id}-connection-status" class="connection-status">
                  <span class="connection-indicator connecting"></span>
                  <span id="${service.id}-connection-text">Awaiting connection...</span>
                </div>
                <label class="auto-scroll-toggle" for="${service.id}-auto-scroll">
                  <div class="checkbox-container">
                    <input type="checkbox" id="${service.id}-auto-scroll" checked>
                    <span class="custom-checkbox"></span>
                  </div>
                  Auto-scroll
                </label>
              </div>

              <pre id="${service.id}-logs" class="logs-area" role="log" aria-live="polite" aria-label="${service.name} service logs"></pre>
            </div>
          </div>
        `;

        tabContentContainer.appendChild(tabContent);

        // Initialize auto-scroll state
        autoScrollStates[service.id] = true;

        // Add event listeners
        document
          .getElementById(`${service.id}-start`)
          .addEventListener("click", () => sendAction(service.id, "start"));
        document
          .getElementById(`${service.id}-stop`)
          .addEventListener("click", () => sendAction(service.id, "stop"));
        document
          .getElementById(`${service.id}-restart`)
          .addEventListener("click", () => sendAction(service.id, "restart"));
        document
          .getElementById(`${service.id}-clear-logs`)
          .addEventListener("click", () => {
            const logArea = document.getElementById(`${service.id}-logs`);
            logArea.textContent = "";
            addLogMessage(
              service.id,
              "Log buffer cleared by user.",
              "system",
              Date.now(),
            );
            sendAction(service.id, "clear_logs"); // Notify server
          });
        document
          .getElementById(`${service.id}-auto-scroll`)
          .addEventListener("change", () => toggleAutoScroll(service.id));

        // Add web link button event listeners if any exist
        if (service.webLinks && service.webLinks.length > 0) {
          service.webLinks.forEach((link, index) => {
            const linkBtn = document.getElementById(
              `${service.id}-weblink-${index}`,
            );
            if (linkBtn) {
              linkBtn.addEventListener("click", () => {
                window.open(link.url, "_blank");
              });
            }
          });
        }

        // Set first tab as active
        if (!activeTabId) {
          switchTab(service.id);
        }
      }

      // Helper function to create web link buttons HTML
      function createWebLinkButtons(service) {
        if (!service.webLinks || service.webLinks.length === 0) {
          return "";
        }

        return service.webLinks
          .map(
            (link, index) => `
          <button id="${service.id}-weblink-${index}" class="web-link-button" title="Open ${link.label}">
            <i>ðŸ”—</i>${link.label}
          </button>
        `,
          )
          .join("");
      }

      function switchTab(serviceID) {
        // Remove active class from all tabs and content
        document.querySelectorAll(".tab-button").forEach((tab) => {
          tab.classList.remove("active");
          tab.setAttribute("aria-selected", "false");
        });
        document.querySelectorAll(".tab-content").forEach((content) => {
          content.classList.remove("active");
          content.setAttribute("tabindex", "-1");
        });

        // Add active class to selected tab and content
        const selectedTab = document.getElementById(`tab-${serviceID}`);
        const selectedContent = document.getElementById(`content-${serviceID}`);

        if (selectedTab && selectedContent) {
          selectedTab.classList.add("active");
          selectedTab.setAttribute("aria-selected", "true");
          selectedContent.classList.add("active");
          selectedContent.setAttribute("tabindex", "0");
          activeTabId = serviceID;
        }
      }

      function toggleAutoScroll(serviceID) {
        const autoScrollCheckbox = document.getElementById(
          `${serviceID}-auto-scroll`,
        );

        autoScrollStates[serviceID] = autoScrollCheckbox.checked;

        if (autoScrollStates[serviceID]) {
          // Scroll to bottom when enabling auto-scroll
          const logArea = document.getElementById(`${serviceID}-logs`);
          if (logArea) {
            logArea.scrollTop = logArea.scrollHeight;
          }
        }
      }

      function startAllServices() {
        if (startAllInProgress) return;

        // Reset all state variables to ensure a fresh start
        startAllInProgress = false; // Reset first to avoid race conditions

        // Clear any existing timeouts
        const startAllStatus = document.getElementById("start-all-status");
        const statusKey = "start-all-status";
        if (statusMessageTimeouts.has(statusKey)) {
          clearTimeout(statusMessageTimeouts.get(statusKey));
          statusMessageTimeouts.delete(statusKey);
        }

        // Check if we're connected to the server
        if (!socket || socket.readyState !== WebSocket.OPEN) {
          startAllStatus.textContent =
            "Cannot start services: Not connected to server";
          startAllStatus.style.color = "#e74c3c"; // Red color for error

          // Clear the error message after a few seconds
          const timeoutId = setTimeout(() => {
            startAllStatus.textContent = "";
            startAllStatus.style.color = ""; // Reset color
            statusMessageTimeouts.delete(statusKey);
          }, 5000);

          statusMessageTimeouts.set(statusKey, timeoutId);
          return;
        }

        startAllInProgress = true;
        const startAllBtn = document.getElementById("start-all-btn");

        startAllBtn.disabled = true;
        startAllStatus.textContent = "Starting services...";
        startAllStatus.style.color = ""; // Reset color

        let currentIndex = 0;
        let startedCount = 0;
        let failedCount = 0;
        let abortStartAll = false;

        // Create a map to track service status changes
        const serviceStartPromises = new Map();
        const serviceStartTimeouts = new Map();

        function startNextService() {
          if (currentIndex >= activeServicesConfig.length || abortStartAll) {
            // All services processed or abort triggered
            finishStartAll();
            return;
          }

          const service = activeServicesConfig[currentIndex];
          const statusElement = document.getElementById(
            service.id + "-status-text",
          );
          const currentStatus = statusElement
            ? statusElement.textContent
            : "unknown";

          // Skip if already running or starting
          if (currentStatus === "Running" || currentStatus === "Starting") {
            currentIndex++;
            startedCount++; // Count as started since it's already running
            startNextService();
            return;
          }

          // Check connection status for this service
          const connectionText = document.getElementById(
            `${service.id}-connection-text`,
          );
          if (connectionText && connectionText.textContent !== "Connected") {
            // Service is not connected, count as failed
            failedCount++;
            currentIndex++;
            startNextService();
            return;
          }

          startAllStatus.textContent = `Starting ${service.name}... (${currentIndex + 1}/${activeServicesConfig.length})`;

          // Create a promise that resolves when the service starts or fails
          const startPromise = new Promise((resolve) => {
            // Set up a listener for status changes
            const statusChangeListener = (event) => {
              try {
                const data = JSON.parse(event.data);
                if (
                  data.type === "status_update" &&
                  data.serviceID === service.id
                ) {
                  if (data.status === "running") {
                    // Service started successfully
                    resolve({ success: true });
                  } else if (
                    data.status === "error" ||
                    data.status === "crashed"
                  ) {
                    // Service failed to start
                    resolve({
                      success: false,
                      errorDetails: data.errorDetails || "Failed to start",
                    });
                  }
                }
              } catch (err) {
                console.error("Error parsing WebSocket message:", err);
              }
            };

            // Add the listener
            socket.addEventListener("message", statusChangeListener);

            // Store the listener so we can remove it later
            serviceStartPromises.set(service.id, {
              resolve,
              listener: statusChangeListener,
            });

            // Set a timeout to abort waiting after 10 seconds
            const timeout = setTimeout(() => {
              if (serviceStartPromises.has(service.id)) {
                resolve({
                  success: false,
                  errorDetails: "Timed out waiting for service to start",
                });
              }
            }, 10000);

            serviceStartTimeouts.set(service.id, timeout);
          });

          // Send start command
          sendAction(service.id, "start");

          // Wait for the service to start or fail
          startPromise.then((result) => {
            // Clean up listeners and timeouts
            const serviceData = serviceStartPromises.get(service.id);
            if (serviceData) {
              socket.removeEventListener("message", serviceData.listener);
              serviceStartPromises.delete(service.id);
            }

            const timeout = serviceStartTimeouts.get(service.id);
            if (timeout) {
              clearTimeout(timeout);
              serviceStartTimeouts.delete(service.id);
            }

            if (result.success) {
              // Service started successfully
              startedCount++;
              currentIndex++;
              startNextService();
            } else {
              // Service failed to start
              failedCount++;
              abortStartAll = true; // Abort starting any more services

              // Show error in status
              startAllStatus.textContent = `Failed to start ${service.name}: ${result.errorDetails}`;
              startAllStatus.style.color = "#e74c3c"; // Red color for error

              // Finish the start all process
              finishStartAll();
            }
          });
        }

        function finishStartAll() {
          // Clean up any remaining listeners and timeouts
          for (const [
            serviceID,
            serviceData,
          ] of serviceStartPromises.entries()) {
            socket.removeEventListener("message", serviceData.listener);
          }
          serviceStartPromises.clear();

          for (const timeout of serviceStartTimeouts.values()) {
            clearTimeout(timeout);
          }
          serviceStartTimeouts.clear();

          // Update UI
          startAllInProgress = false;
          startAllBtn.disabled = false;

          // Clear any existing timeout
          const statusKey = "start-all-status";
          if (statusMessageTimeouts.has(statusKey)) {
            clearTimeout(statusMessageTimeouts.get(statusKey));
            statusMessageTimeouts.delete(statusKey);
          }

          let timeoutId;

          if (abortStartAll) {
            // We already set the error message when aborting
            // Just ensure it stays visible longer
            timeoutId = setTimeout(() => {
              startAllStatus.textContent = "";
              startAllStatus.style.color = ""; // Reset color
              statusMessageTimeouts.delete(statusKey);
            }, 8000);
          } else if (failedCount > 0) {
            startAllStatus.textContent = `${startedCount} services started, ${failedCount} failed`;
            startAllStatus.style.color = "#e67e22"; // Orange for warning
            timeoutId = setTimeout(() => {
              startAllStatus.textContent = "";
              startAllStatus.style.color = ""; // Reset color
              statusMessageTimeouts.delete(statusKey);
            }, 5000);
          } else {
            startAllStatus.textContent = "All services started!";
            startAllStatus.style.color = "#2ecc71"; // Green for success
            timeoutId = setTimeout(() => {
              startAllStatus.textContent = "";
              startAllStatus.style.color = ""; // Reset color
              statusMessageTimeouts.delete(statusKey);
            }, 5000);
          }

          statusMessageTimeouts.set(statusKey, timeoutId);
        }

        startNextService();
      }

      function sendAction(serviceID, action) {
        if (socket && socket.readyState === WebSocket.OPEN) {
          socket.send(JSON.stringify({ action, serviceID }));
        } else {
          console.error("WebSocket not connected.");

          // Update connection status to show disconnection
          updateConnectionStatus(
            serviceID,
            "disconnected",
            "Not connected to server",
          );

          // Show a temporary error message for the specific action
          const errorDetailsElement = document.getElementById(
            serviceID + "-error-details",
          );

          if (errorDetailsElement) {
            // Clear any existing timeout for this error element
            const errorKey = `${serviceID}-error`;
            if (errorMessageTimeouts.has(errorKey)) {
              clearTimeout(errorMessageTimeouts.get(errorKey));
              errorMessageTimeouts.delete(errorKey);
            }

            // Show action-specific error
            errorDetailsElement.textContent = `Cannot ${action} service: Not connected to server. Please check your connection.`;
            errorDetailsElement.style.display = "block";

            // Auto-hide the error after 5 seconds
            const timeoutId = setTimeout(() => {
              errorDetailsElement.style.display = "none";
              errorMessageTimeouts.delete(errorKey);
            }, 5000);

            errorMessageTimeouts.set(errorKey, timeoutId);
          }
        }
      }

      function connectWebSocket() {
        const wsProtocol =
          window.location.protocol === "https:" ? "wss:" : "ws:";
        const wsUrl = `${wsProtocol}//${window.location.host}/ws`;
        socket = new WebSocket(wsUrl);

        socket.onopen = () => {
          console.log("WebSocket connected.");
          activeServicesConfig.forEach((service) => {
            updateConnectionStatus(service.id, "connected", "Connected");

            // Clear any error messages when connection is established
            const errorDetailsElement = document.getElementById(
              `${service.id}-error-details`,
            );

            const errorKey = `${service.id}-error`;

            if (errorDetailsElement) {
              errorDetailsElement.style.display = "none";
              if (errorMessageTimeouts.has(errorKey)) {
                clearTimeout(errorMessageTimeouts.get(errorKey));
                errorMessageTimeouts.delete(errorKey);
              }
            }
          });
        };

        socket.onmessage = (event) => {
          const data = JSON.parse(event.data);
          switch (data.type) {
            case "initial_state":
              data.services.forEach((s) => {
                if (!document.getElementById(`tab-${s.id}`)) {
                  console.warn(
                    `Service tab for ${s.id} not found during initial_state, creating now.`,
                  );
                }
                updateServiceStatus(s.id, s.status, s.errorDetails);
                updateConnectionStatus(s.id, "connected", "Connected");
                const logArea = document.getElementById(s.id + "-logs");
                if (logArea) logArea.textContent = ""; // Clear before populating history
                s.logs.forEach((log) =>
                  addLogMessage(s.id, log.line, log.logType, log.timestamp),
                );
              });
              break;
            case "log":
              addLogMessage(
                data.serviceID,
                data.line,
                data.logType,
                data.timestamp,
              );
              break;
            case "status_update":
              updateServiceStatus(
                data.serviceID,
                data.status,
                data.errorDetails,
              );
              break;
            case "logs_cleared":
              const logArea = document.getElementById(data.serviceID + "-logs");
              if (logArea) {
                logArea.textContent = "";
                addLogMessage(
                  data.serviceID,
                  "Log buffer cleared by user.",
                  "system",
                  Date.now(),
                );
              }
              break;
            case "error_from_server":
              alert(`Server error: ${data.message}`);
              if (data.serviceID) {
                const serviceErrorArea = document.getElementById(
                  data.serviceID + "-error-details",
                );
                if (serviceErrorArea) {
                  serviceErrorArea.textContent = data.message;
                  serviceErrorArea.style.display = "block";
                }
              }
              break;
          }
        };

        socket.onclose = (event) => {
          console.log(
            "WebSocket disconnected. Code:",
            event.code,
            "Reason:",
            event.reason,
            "WasClean:",
            event.wasClean,
          );
          activeServicesConfig.forEach((service) => {
            updateServiceStatus(service.id, "stopped", "Disconnected");

            // Update connection status to show disconnection
            updateConnectionStatus(
              service.id,
              "disconnected",
              "Disconnected. Retrying...",
            );

            // Clear any existing error timeouts
            const errorKey = `${service.id}-error`;
            if (errorMessageTimeouts.has(errorKey)) {
              clearTimeout(errorMessageTimeouts.get(errorKey));
              errorMessageTimeouts.delete(errorKey);
            }

            // Hide any existing error messages as the connection status will show the state
            const errorDetailsElement = document.getElementById(
              `${service.id}-error-details`,
            );
            if (errorDetailsElement) {
              errorDetailsElement.style.display = "none";
            }
          });
          setTimeout(connectWebSocket, 3000);
        };

        socket.onerror = (error) => {
          console.error("WebSocket error:", error);
          activeServicesConfig.forEach((service) => {
            // Update connection status to show error
            updateConnectionStatus(
              service.id,
              "disconnected",
              "Connection error",
            );

            // Clear any existing error timeouts
            const errorKey = `${service.id}-error`;
            if (errorMessageTimeouts.has(errorKey)) {
              clearTimeout(errorMessageTimeouts.get(errorKey));
              errorMessageTimeouts.delete(errorKey);
            }

            // Hide any existing error messages as the connection status will show the state
            const errorDetailsElement = document.getElementById(
              `${service.id}-error-details`,
            );
            if (errorDetailsElement) {
              errorDetailsElement.style.display = "none";
            }
          });
        };
      }

      function updateConnectionStatus(serviceID, status, message) {
        const connectionStatusText = document.getElementById(
          `${serviceID}-connection-text`,
        );
        const connectionIndicator = document.querySelector(
          `#${serviceID}-connection-status .connection-indicator`,
        );

        // If we're updating the connection status, clear any existing error timeout
        const errorDetailsElement = document.getElementById(
          `${serviceID}-error-details`,
        );

        const errorKey = `${serviceID}-error`;

        if (errorDetailsElement && errorMessageTimeouts.has(errorKey)) {
          clearTimeout(errorMessageTimeouts.get(errorKey));
          errorMessageTimeouts.delete(errorKey);

          // If we're connecting successfully, hide any error messages immediately
          if (status === "connected") {
            errorDetailsElement.style.display = "none";
          }
        }

        if (connectionStatusText) {
          connectionStatusText.textContent = message;
        }

        if (connectionIndicator) {
          connectionIndicator.className = `connection-indicator ${status}`;
        }

        // Clear logs area if it contains only connection messages
        const logArea = document.getElementById(`${serviceID}-logs`);
        if (
          logArea &&
          (logArea.textContent === "Awaiting connection..." ||
            logArea.textContent ===
              "Connection open. Waiting for initial state..." ||
            logArea.textContent.includes("Disconnected. Retrying..."))
        ) {
          logArea.textContent = "";
        }
      }

      function addLogMessage(serviceID, line, logType = "stdout", timestamp) {
        const logArea = document.getElementById(serviceID + "-logs");
        if (!logArea) return;

        const logLineElement = document.createElement("span");
        logLineElement.className = `log-line log-${logType}`;

        const ts = new Date(timestamp).toLocaleTimeString();
        logLineElement.textContent = `[${ts}] ${line}`;

        logArea.appendChild(logLineElement);
        logArea.appendChild(document.createTextNode("\n"));

        while (logArea.childNodes.length > MAX_CLIENT_LOGS + 10) {
          logArea.removeChild(logArea.firstChild);
        }

        // Only auto-scroll if enabled for this service
        if (autoScrollStates[serviceID]) {
          logArea.scrollTop = logArea.scrollHeight;
        }
      }

      function updateServiceStatus(serviceID, status, errorDetails = null) {
        const statusTextElement = document.getElementById(
          serviceID + "-status-text",
        );
        const statusIndicatorElement = document.getElementById(
          serviceID + "-status-indicator",
        );
        const tabStatusIndicatorElement = document.getElementById(
          serviceID + "-tab-status-indicator",
        );
        const errorDetailsElement = document.getElementById(
          serviceID + "-error-details",
        );

        // Capitalize first letter of status
        const capitalizedStatus =
          status.charAt(0).toUpperCase() + status.slice(1);

        if (statusTextElement)
          statusTextElement.textContent = capitalizedStatus;
        if (statusIndicatorElement)
          statusIndicatorElement.className = `status-indicator status-${status}`;
        if (tabStatusIndicatorElement)
          tabStatusIndicatorElement.className = `tab-status-indicator status-${status}`;

        const startButton = document.getElementById(serviceID + "-start");
        const stopButton = document.getElementById(serviceID + "-stop");
        const restartButton = document.getElementById(serviceID + "-restart");

        if (startButton && stopButton && restartButton) {
          startButton.disabled =
            status === "running" ||
            status === "starting" ||
            status === "stopping";
          stopButton.disabled =
            status === "stopped" ||
            status === "error" ||
            status === "crashed" ||
            status === "starting" ||
            status === "stopping";
          restartButton.disabled =
            status === "starting" || status === "stopping";
        }

        if (errorDetailsElement) {
          if ((status === "error" || status === "crashed") && errorDetails) {
            const statusLabel = status === "crashed" ? "Crash" : "Error";
            errorDetailsElement.textContent = `${statusLabel}: ${errorDetails}`;
            errorDetailsElement.style.display = "block";
          } else {
            errorDetailsElement.textContent = "";
            errorDetailsElement.style.display = "none";
          }
        }
      }

      document.addEventListener("DOMContentLoaded", () => {
        fetch("/api/services-config")
          .then((response) => {
            if (!response.ok) {
              throw new Error(`HTTP error! status: ${response.status}`);
            }
            return response.json();
          })
          .then((fetchedServicesConfig) => {
            activeServicesConfig = fetchedServicesConfig;
            activeServicesConfig.forEach((service) =>
              createServiceTab(service),
            );

            // Add event listener for Start All button
            document
              .getElementById("start-all-btn")
              .addEventListener("click", startAllServices);

            connectWebSocket();
          })
          .catch((error) => {
            console.error("Error fetching services config:", error);
            const container = document.getElementById("tab-content-container");
            if (container) {
              container.innerHTML = `<p style="color: red; text-align: center;">Failed to load service configurations: ${error.message}. Please check if the Dev Services Dashboard server is running correctly.</p>`;
            }
          });
      });

      // Add keyboard navigation for tabs
      document.addEventListener("keydown", function (e) {
        // Only handle if we have tabs and one is active
        if (!activeTabId) return;

        const tabs = document.querySelectorAll(".tab-button");
        if (!tabs.length) return;

        const currentIndex = Array.from(tabs).findIndex(
          (tab) => tab.id === `tab-${activeTabId}`,
        );
        if (currentIndex === -1) return;

        // Left arrow: previous tab
        if (
          e.key === "ArrowLeft" &&
          document.activeElement.classList.contains("tab-button")
        ) {
          const prevIndex = (currentIndex - 1 + tabs.length) % tabs.length;
          const prevTabId = tabs[prevIndex].id.replace("tab-", "");
          switchTab(prevTabId);
          tabs[prevIndex].focus();
          e.preventDefault();
        }

        // Right arrow: next tab
        if (
          e.key === "ArrowRight" &&
          document.activeElement.classList.contains("tab-button")
        ) {
          const nextIndex = (currentIndex + 1) % tabs.length;
          const nextTabId = tabs[nextIndex].id.replace("tab-", "");
          switchTab(nextTabId);
          tabs[nextIndex].focus();
          e.preventDefault();
        }
      });
    </script>
  </body>
</html>
